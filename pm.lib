// # `pm.lib`: Physical Modeling Library

import("stdfaust.lib");

/*
TODO:
	- It'd be cool to have a version of the block diagram generator that automatically flips
	things based on the use of chains, etc.
	-
*/

//=============================Global Variables===========================================
// Useful pre-defined variables for physical modeling.
//========================================================================================

//--------------`speedOfSound`----------
// Speed of sound in meters per second (340m/s).
//--------------------------------------
speedOfSound = 340;

//================================Conversion Tools=======================================
// Useful conversion tools for physical modeling.
//========================================================================================

//--------------`f2l`----------
// Frequency to lentgh in meters.
//
// #### Usage
//
// ```
// f2l(freq) : distanceInMeters
// ```
//
// Where:
//
// * `freq`: the frequency
//-------------------------------
f2l(freq) = speedOfSound/freq;

//--------------`l2s`----------
// Length in meters to number of samples.
//
// #### Usage
//
// ```
// l2s(l) : numberOfSamples
// ```
//
// Where:
//
// * `l`: length in meters
//-------------------------------
l2s(l) = l*ma.SR/speedOfSound;

//=============================Bidirectional Utilities====================================
// Set of fundamental functions to create bi-directional block diagrams in Faust.
// These elements are used as the basis of this library.
//========================================================================================

//--------------`basicBlock`----------
// Empty bidirectional block to be used with [`chain`](#chain): 3 signals ins and 3 signals out.
//
// #### Usage
//
// ```
// chain(basicBlock : basicBlock : etc.)
// ```
//-------------------------------
basicBlock = _,_,_;

//-------`chain`----------
// Creates a chain of bidirectional blocks.
// Blocks must have 3 inputs and outputs. The first input/output correspond to the left
// going signal, the second input/output correspond to the right going signal and the
// third input/output is the mix of the main signal output. The implied one sample delay
// created by the `~` operator is generalized to the left and right going waves. Thus, n
// blocks in `chain()` will add an n samples delay to both the left and right going waves.
//
// #### Usage
//
// ```
// rightGoingWaves,leftGoingWaves,mixedOutput : chain(A:B) : rightGoingWaves,leftGoingWaves,mixedOutput
// with{
// 		A = _,_,_;
//		B = _,_,_;
// };
// ```
//-----------------------------
chain(A:As) = ((ro.crossnn(1),_',_ : _,A : ro.crossnn(1),_,_ : _,chain(As) : ro.crossnn(1),_,_)) ~ _ : !,_,_,_;
chain(A) = A;

//-------`inLeftWave`--------------
// Adds a signal to left going waves anywhere in a [`chain`](#chain) of blocks.
//
// #### Usage
//
// ```
// model(x) = chain(A : inLeftWave(x) : B)
// ```
//
// Where `A` and `B` are bidirectional blocks and `x` is the signal added to left
// going waves in that chain.
//--------------------------------
inLeftWave(x) = +(x),_,_;

//-------`inRightWave`--------------
// Adds a signal to right going waves anywhere in a [`chain`](#chain) of blocks.
//
// #### Usage
//
// ```
// model(x) = chain(A : inRightWave(x) : B)
// ```
//
// Where `A` and `B` are bidirectional blocks and `x` is the signal added to right
// going waves in that chain.
//--------------------------------
inRightWave(x) = _,+(x),_;

//-------`in`--------------
// Adds a signal to left and right going waves anywhere in a [`chain`](#chain)
// of blocks.
//
// #### Usage
//
// ```
// model(x) = chain(A : in(x) : B)
// ```
//
// Where `A` and `B` are bidirectional blocks and `x` is the signal added to
// left and right going waves in that chain.
//--------------------------------
in(x) = +(x),+(x),_;

//-------`outLeftWave`--------------
// Sends the signal of left going waves to the output channel of the [`chain`](#chain).
//
// #### Usage
//
// ```
// chain(A : outLeftWave : B)
// ```
//
// Where
//
// Where `A` and `B` are bidirectional blocks.
//--------------------------------
outLeftWave(x,y,s) = x,y,x+s;

//-------`outRightWave`--------------
// Sends the signal of right going waves to the output channel of the [`chain`](#chain).
//
// #### Usage
//
// ```
// chain(A : outRightWave : B)
// ```
//
// Where
//
// Where `A` and `B` are bidirectional blocks.
//--------------------------------
outRightWave(x,y,s) = x,y,y+s;

//-------`out`--------------
// Sends the signal of right and left going waves to the output channel of the [`chain`](#chain).
//
// #### Usage
//
// ```
// chain(A : out : B)
// ```
//
// Where
//
// Where `A` and `B` are bidirectional blocks.
//--------------------------------
out(x,y,s) = x,y,x+y+s;

//-------`terminations`--------------
// Creates terminations on both sides of a [`chain`](#chain) without closing the inputs and
// outputs of the bidirectional signals chain. As for [`chain`](#chain), this function adds a 1
// sample delay to the bidirectional signal, both ways. Of courses, this function can be nested
// within a [`chain`](#chain).
//
// #### Usage
//
// ```
// rightGoingWaves,leftGoingWaves,mixedOutput : terminations(a,b,c) : rightGoingWaves,leftGoingWaves,mixedOutput
// with{
//		a = *(-1); // left termination
//		b = chain(D:E:F); // bidirectional chain of blocks (D, E, F, etc.)
//		c = *(-1); // right termination
// };
// ```
//----------------------------------------
terminations(a,b,c) = (_,ro.crossnn(1),_,_ : +,+,_ : b) ~ (a,c : ro.crossnn(1));

//-------`leftTermination`----------
// Creates a termination on the left side of a [`chain`](#chain) without closing the inputs and
// outputs of the bidirectional signals chain. This function adds a 1 sample delay near
// the termination and can be nested within another [`chain`](#chain).
//
// #### Usage
//
// ```
// rightGoingWaves,leftGoingWaves,mixedOutput : terminations(a,b) : rightGoingWaves,leftGoingWaves,mixedOutput
// with{
//		a = *(-1); // left termination
//		b = chain(D : E : F); // bidirectional chain of blocks (D, E, F, etc.)
// };
// ```
//----------------------------------------
lTermination(a,b) = (ro.crossnn(1),_,_ : _,+,_ : b) ~ a;

//-------`rTermination`----------
// Creates a termination on the right side of a [`chain`](#chain) without closing the inputs and
// outputs of the bidirectional signals chain. This function adds a 1 sample delay near
// the termination and can be nested within another [`chain`](#chain).
//
// #### Usage
//
// ```
// rightGoingWaves,leftGoingWaves,mixedOutput : terminations(b,c) : rightGoingWaves,leftGoingWaves,mixedOutput
// with{
//		b = chain(D : E : F); // bidirectional chain of blocks (D, E, F, etc.)
//		c = *(-1); // right termination
// };
// ```
//----------------------------------------
rTermination(b,c) = (_,_,_,_ : +,_,_ : b) ~ (!,c);

//-------`closeIns`----------
// Closes the inputs of a bidirectional chain in all directions.
//
// #### Usage
//
// ```
// closeIns : chain(...) : 	_,_,_
// ```
//----------------------------------------
closeIns = 0,0,0;

//-------`closeOuts`----------
// Closes the outputs of a bidirectional chain in all directions except for the
// main signal output (3d output).
//
// #### Usage
//
// ```
// _,_,_ : chain(...) : closeOuts
// ```
//----------------------------------------
closeOuts = !,!,_;

//-------`endChain`----------
// Closes the inputs and outputs of a bidirectional chain in all directions
// except for the main signal output (3d output).
//
// #### Usage
//
// ```
// endChain(chain(...))
// ```
//----------------------------------------
endChain(b) = closeIns : b : closeOuts;


//==================================Basic Elements========================================
// Basic bidirectional blocks for physical modeling.
//========================================================================================

//-------`waveguideN`----------
// A series of waveguide function based on various types of delays.
//
// #### List of functions
//
// * `waveguideUd`: unit delay waveguide
// * `waveguideFd`: fractional delay waveguide
// * `waveguideFd2`: second order fractional delay waveguide
// * `waveguideFd4`: fourth order fractional delay waveguide
//
// #### Usage
//
// ```
// chain(A : waveguideUd(nMax,n) : B)
// ```
//
// Where:
//
// * `nMax`: the maximum length of the delays in the waveguide as a power of 2
// * `n` the length of the delay lines in samples.
//----------------------------------
waveguideUd(nMax,n) = par(i,2,de.delay(nMax,n)),_;
waveguideFd(nMax,n) = par(i,2,de.fdelay(nMax,n)),_;
waveguideFd2(nMax,n) = par(i,2,de.fdelay2(nMax,n)),_;
waveguideFd4(nMax,n) = par(i,2,de.fdelay4(nMax,n)),_;

//-------`waveguide`----------
// Standard `pm.lib` waveguide (based on `waveguideFd4`).
//
// #### Usage
//
// ```
// chain(A : waveguide(nMax,n) : B)
// ```
//
// Where:
//
// * `nMax`: the maximum length of the delays in the waveguide as a power of 2
// * `n` the length of the delay lines in samples.
//----------------------------------
waveguide(nMax,n) = waveguideFd4(nMax,n);

// TODO doc
ksReflexionFilter = _ <: (_+_')/2;

//========================Basic String Instruments Elements===============================
// Low and high level basic string instruments parts.
//========================================================================================

//-------`openString`----------
// A string segment without terminations.
//
// #### Usage
//
// ```
// chain(A : openString(maxLength,length) : B)
// ```
//
// Where:
//
// * `maxLength`: the maximum length of the string in meters (should be static)
// * `length`: the length of the string in meters
//----------------------------------
openString(maxLength,length) = waveguide(nMax,n)
with{
	//nMax = maxLength : l2s/2 : ma.np2; // TODO: for now, not rounded to next power of 2, which is probably fine
	nMax = maxLength : l2s;
	n = length : l2s/2;
};

//-------`rStringRigidTermination`----------
// Right rigid string termination (no damping, just phase inversion).
//
// #### Usage
//
// ```
// chain(rStringRigidTermination : openString : ...)
// ```
//----------------------------------
rStringRigidTermination = rTermination(basicBlock,*(-1));

//-------`lStringRigidTermination`----------
// Left rigid string termination (no damping, just phase inversion).
//
// #### Usage
//
// ```
// chain(... : openString : lStringRigidTermination)
// ```
//----------------------------------
lStringRigidTermination = lTermination(*(-1),basicBlock);

// TODO doc
ksString(length,damping,excitation) = endChain(ksChain)
with{
	lengthTuning = 0.94;
	tunedLength = length*lengthTuning;
	refCoef = (1-damping)*0.2+0.8;
	refFilter = ksReflexionFilter*refCoef;
	ksChain = terminations(_,chain(in(excitation) : openString(tunedLength) : out),refFilter);
};

//=========================Bowed String Instruments Elements==============================
// Low and high level bowed string instruments parts.
//========================================================================================

//-------`bowTable`----------
// Extremely basic bow table that can be used to implement a wide range of
// bow types for many different bowed string instruments (violin, cello, etc.)
//
// #### Usage
//
// ```
// excitation : bowTable(offeset,slope) : _
// ```
//
// Where:
//
// * `excitation`: an excitation signal
// * `offset`: table offset
// * `slope`: table slope
//----------------------------------
bowTable(offset,slope) = pow(abs(sample) + 0.75, -4) : min(1)
with{
	sample = +(offset)*slope;
};


//-------`violinBow`----------
// Violin bow based on [`bowTable`](#bowtable).
//
// #### Usage
//
// ```
// bowVelocity : violinBow(bowPressure) : _
// ```
//
// Where:
//
// * `bowVelocity`: velocity of the bow/excitation signal (0-1)
// * `bowPressure`: bow pressure on the string (0-1)
//----------------------------------
violinBow(bowPressure) = bowTable(0,tableSlope)
with{
	tableSlope = 5 - (4*bowPressure);
};

//-------`bowInteraction`----------
// Bidirectional block implementing the interaction of a bow in a
// [`chain`](#chain).
//
// #### Usage
//
// ```
// chain(... : openString : bowInteraction(bow) : openString : ...)
// ```
//
// Where:
//
// * `bow`: the bow
//----------------------------------
bowInteraction(b) = (_,_ <: b,_,_ :> _,_),_;

//-------`violinBowInteraction`----------
// Bidirectional block implementing a violin bow interaction.
//
// #### Usage
//
// ```
// chain(... : openString : violinBowInteraction(bowPressure,bowVelocity) : openString : ...)
// ```
//
// Where:
//
// * `bowVelocity`: velocity of the bow / excitation signal (0-1)
// * `bowPressure`: bow pressure on the string (0-1)
//----------------------------------
violinBowInteraction(bowPressure,bowVelocity) = bowInteraction(bowSystem)
with{
	bowSystem = + : bowVelocity-_ <: *(violinBow(bowPressure)) <: _,_;
};

//-------`violinBowedString`----------
// Violin bowed string bidirectional block. Terminations are not implemented
// in this model
//
// #### Usage
//
// ```
// chain(nut : violinBowedString(stringLength,bowPressure,bowVelocity,bowPosition) : bridge)
// ```
//
// Where:
//
// * `stringLength`: the length of the string in meters
// * `bowVelocity`: velocity of the bow / excitation signal (0-1)
// * `bowPressure`: bow pressure on the string (0-1)
// * `bowPosition`: the position of the bow on the string (0-1)
//----------------------------------
violinBowedString(stringLength,bowPressure,bowVelocity,bowPosition) =
	chain(
		openString(maxStringLength,ntbd) :
		violinBowInteraction(bowPressure,bowVelocity) :
		openString(maxStringLength,btbd)
	)
with{
	stringTuning = 0.95;
	maxStringLength = 1; // meters
	stringL = stringLength*stringTuning;
	ntbd = stringL*bowPosition;
	btbd = stringL*(1-bowPosition);
};

//-------`violinNut`----------
// Dirt simple implementation of a violin "nut": rigid termination.
//
// #### Usage
//
// ```
// chain(violinNut : openString : ...)
// ```
//----------------------------------
violinNut = lStringRigidTermination;

//-------`violinBridge`----------
// Bidirectional block implementing a simple violin bridge.
//
// #### Usage
//
// ```
// chain(... : openString : violinBridge(reflexion,absorption))
// ```
//
// Where:
//
// * `relfexion`: reflexion coefficient determining the resonance duration of the string (0-1) (recommended: 0.95)
// * `absorption`: absorption coefficient - controls the cuttoff frequency of the corresponding lowpass filter (0-1) (recommended: 0.4)
//----------------------------------
// TODO:
// 	* reflectance is not implemented yet
violinBridge(reflexion,absorption) = rTermination(basicBlock,reflectance) : _,transmittance,_
with{
	reflectance = *(-reflexion) : si.smooth(1-absorption);
	transmittance = _;
};

//-------`violinBody`----------
// Bidirectional block implementing a simple violin body.
//
// #### Usage
//
// ```
// chain(... : openString : violinBridge : violinBody)
// ```
//----------------------------------
// TODO:
// 	* reflectance is not implemented yet
violinBody = reflectance,transmittance,_
with{
	transmittance = fi.resonbp(500,2,1);
	reflectance = _;
};

//-------`basicViolinModel`----------
// Ready-to-use basic violin physical model.
//
// #### Usage
//
// ```
// basicViolinModel(stringLength,bowPressure,bowVelocity,bridgeReflexion,bridgeAbsorption,bowPosition) : _
// ```
//
// Where:
//
// * `stringLength`: the length of the string in meters
// * `bowVelocity`: velocity of the bow / excitation signal (0-1)
// * `bowPressure`: bow pressure on the string (0-1)
// * `bridegRelfexion`: reflexion coefficient determining the resonance duration of the string (0-1) (recommended: 0.95)
// * `bridgeAbsorption`: absorption coefficient - controls the cuttoff frequency of the corresponding lowpass filter (0-1) (recommended: 0.4)
// * `bowPosition`: the position of the bow on the string (0-1)
//----------------------------------
basicViolinModel(stringLength,bowPressure,bowVelocity,bridgeReflexion,bridgeAbsorption,bowPosition) =
	endChain(modelChain)
with{
	modelChain = chain(
		violinNut :
		violinBowedString(stringLength,bowPressure,bowVelocity,bowPosition) :
		violinBridge(bridgeReflexion,bridgeAbsorption) :
		violinBody :
		out
	);
};

//-------`basicViolinModel_ui`----------
// Ready-to-use violin physical model with built-in UI.
//
// #### Usage
//
// ```
// basicViolinModel_ui : _
// ```
//----------------------------------
basicViolin_ui = basicViolinModel(stringLength,bowPress,bowVel,bridgeReflexion,bridgeAbsorption,bowPos)
with{
	stringLength = hslider("v:violinModel/v:[0]string/[0]length",0.75,0,1,0.01);
	bowVel = hslider("v:violinModel/v:[1]bow/[0]velocity",0,0,1,0.01) : si.smoo;
	bowPress = hslider("v:violinModel/v:[1]bow/[1]pressure",0.5,0,1,0.01);
	bowPos = hslider("v:violinModel/v:[1]bow/[2]position",0.7,0,1,0.01);
	bridgeReflexion = hslider("v:violinModel/v:[2]bridge/[0]reflexion",0.95,0,1,0.01);
	bridgeAbsorption = hslider("v:violinModel/v:[2]bridge/[1]absorption",0.4,0,1,0.01);
};

//-------`basicViolinModel_ui_MIDI`----------
// Ready-to-use MIDI-enabled violin physical model with built-in UI.
//
// #### Usage
//
// ```
// basicViolinModel_ui_MIDI : _
// ```
//----------------------------------
basicViolin_ui_MIDI = basicViolinModel(stringLength,bowPress,bowVel,bridgeReflexion,bridgeAbsorption,bowPos)
with{
	f = hslider("v:violinModel/v:[0]midi/[0]freq",440,50,1000,0.01);
	bend = hslider("v:violinModel/v:[0]midi/[1]bend[hide:1][midi:pitchwheel]",1,0,10,0.01) : si.polySmooth(gate,0.999,1);
	gain = hslider("v:violinModel/v:[0]midi/[2]gain",0.6,0,1,0.01); // TODO: this might need some tuning
	envAttack = hslider("v:violinModel/v:[0]midi/[3]envAttack",1,0,30,0.01)*0.001;
	s = hslider("v:violinModel/v:[0]midi/[4]sustain[hide:1][midi:ctrl 64]",0,0,1,1);
	t = button("v:violinModel/v:[0]midi/[5]gate");
	bowPress = hslider("v:violinModel/v:[1]bow/[0]pressure",0.5,0,1,0.01);
	bowPos = hslider("v:violinModel/v:[1]bow/[1]position",0.7,0,1,0.01);
	bridgeReflexion = hslider("v:violinModel/v:[2]bridge/[0]reflexion",0.95,0,1,0.01);
	bridgeAbsorption = hslider("v:violinModel/v:[2]bridge/[1]absorption",0.4,0,1,0.01);
	vibratoFreq = hslider("v:violinModel/v:[2]vibrato/[0]frequency",6,1,10,0.01);
	vibratoGain = hslider("v:violinModel/v:[2]vibrato/[1]gain",0.25,0,1,0.01)*0.01;

	gate = t+s : min(1);
	vibrato = 1+os.osc(vibratoFreq)*vibratoGain*envelope;
	freq = f*bend*vibrato;
	envelope = gate*gain : si.smooth(ba.tau2pole(envAttack));

	stringLength = freq : f2l;
	bowVel = envelope;
};

//===========================Wind Instrument Elements=====================================
// Low and high level wind instrument parts.
//========================================================================================

//-------`openTube`----------
// A tube segment without terminations (same as [`openString`](#openstring)).
//
// #### Usage
//
// ```
// chain(A : openTube(maxLength,length) : B)
// ```
//
// Where:
//
// * `maxLength`: the maximum length of the tube in meters (should be static)
// * `length`: the length of the tube in meters
//----------------------------------
openTube = openString;

//-------`reedTable`----------
// Extremely basic reed table that can be used to implement a wide range of
// single reed types for many different instruments (saxophone, clarinet, etc.)
//
// #### Usage
//
// ```
// excitation : reedTable(offeset,slope) : _
// ```
//
// Where:
//
// * `excitation`: an excitation signal
// * `offset`: table offset
// * `slope`: table slope
//----------------------------------
reedTable(offset,slope) = reedTable : min(1) : max(-1)
with {
	reedTable = *(slope) + offset;
};

//-------`clarinetReed`----------
// Clarinet reed based on [`reedTable`](#reedtable).
//
// #### Usage
//
// ```
// excitation : clarinetReed(stiffness) : _
// ```
//
// Where:
//
// * `excitation`: an excitation signal
// * `stiffness`: reed stiffness (0-1)
//----------------------------------
clarinetReed(stiffness) = reedTable(0.7,tableSlope)
with{
	tableSlope = -0.44 + 0.26*stiffness;
};

//-------`clarinetMouthPiece`----------
// Bidirectional block implementing a clarinet mouthpiece as well as the various
// interactions happening with traveling waves. This element is ready to be
// plugged to a tube...
//
// #### Usage
//
// ```
// chain(clarinetMouthPiece(reedStiffness,pressure) : tube : etc.)
// ```
//
// Where:
//
// * `pressure`: the pressure of the air flow created by the virtual performer (0-1).
// This can also be any kind of signal that will directly injected in the mouthpiece
// (e.g., breath noise, etc.)
// * `reedStiffness`: reed stiffness (0-1)
//----------------------------------
// TODO potentially, this function should be broken appart the same way we did it for bow
// and bowInteraction
clarinetMouthPiece(reedStiffness,pressure) = lTermination(reedInteraction,in(pressure))
with{
	reedInteraction = *(-1) <: *(clarinetReed(reedStiffness));
};

//-------`wBell`----------
// Generic wind instrument bell bidirectional block that should be placed at
// the end of a [`chain`](#chain).
//
// #### Usage
//
// ```
// chain(... : wBell(opening))
// ```
//
// Where:
//
// * `opening`: the opening of bell (0-1)
//----------------------------------
wBell(opening) = rTermination(basicBlock,si.smooth(opening));

//-------`basicClarinetModel`----------
// A basic clarinet physical model.
//
// #### Usage
//
// ```
// basicClarinetModel(length,pressure,reedStiffness,bellOpening) : _
// ```
//
// Where:
//
// * `tubeLength`: the length of the tube in meters
// * `pressure`: the pressure of the air flow created by the virtual performer (0-1).
// This can also be any kind of signal that will directly injected in the mouthpiece
// (e.g., breath noise, etc.)
// * `reedStiffness`: reed stiffness (0-1)
// * `bellOpening`: the opening of bell (0-1)
//----------------------------------
basicClarinetModel(tubeLength,pressure,reedStiffness,bellOpening) = endChain(modelChain)
with{
	lengthTuning = 0.95; // empirical adjustment of the tuning of the tube
	maxTubeLength = 1; // meters
	tunedLength = tubeLength*lengthTuning;
	modelChain =
		chain(
			clarinetMouthPiece(reedStiffness,pressure) :
			openTube(maxTubeLength,tunedLength) :
			wBell(bellOpening) : out
		);
};

//-------`basicClarinetModel_ui`----------
// Same as [`basicClarinetModel`](#basicClarinetModel) but with a built-in UI.
//
// #### Usage
//
// ```
// basicClarinetModel_ui(pressure) : _
// ```
//
// Where:
//
// * `pressure`: the pressure of the air flow created by the virtual performer (0-1).
// This can also be any kind of signal that will directly injected in the mouthpiece
// (e.g., breath noise, etc.)
//----------------------------------
basicClarinetModel_ui(pressure) = basicClarinetModel(tubeLength,pressure,reedStiffness,bellOpening)
with{
	tubeLength = hslider("v:clarinetModel/[0]tubeLength",0.8,0.01,3,0.01) : si.smoo;
	reedStiffness = hslider("v:clarinetModel/[1]reedStiffness",0.5,0,1,0.01);
	bellOpening = hslider("v:clarinetModel/[2]bellOpening",0.5,0,1,0.01);
};

//-------`basicClarinet_ui`----------
// Ready-to-use clarinet physical model with built-in UI.
//
// #### Usage
//
// ```
// basicClarinet_ui : _
// ```
//----------------------------------
basicClarinet_ui = hgroup("clarinet",blower_ui : basicClarinetModel_ui);

//-------`basicClarinet_ui_MIDI`----------
// Ready-to-use MIDI compliant clarinet physical model with built-in UI.
//
// #### Usage
//
// ```
// basicClarinet_ui_MIDI : _
// ```
//----------------------------------
basicClarinet_ui_MIDI =  basicClarinetModel(tubeLength,blow,reedStiffness,bellOpening)
with{
	f = hslider("v:clarinetMidi/[0]freq",440,50,1000,0.01);
	bend = hslider("v:clarinetMidi/[1]bend[hide:1][midi:pitchwheel]",1,0,10,0.01) : si.polySmooth(gate,0.999,1);
	gain = hslider("v:clarinetMidi/[2]gain",0.6,0,1,0.01);
	reedStiffness = hslider("v:clarinetMidi/[3]reedStiffness[midi:ctrl 1]",0.5,0,1,0.01);
	bellOpening = hslider("v:clarinetMidi/[4]bellOpening[midi:ctrl 3]",0.5,0,1,0.01);
	vibratoFreq = hslider("v:clarinetMidi/[5]vibratoFreq",6,1,10,0.01);
	vibratoGain = hslider("v:clarinetMidi/[6]vibratoGain",0.25,0,1,0.01)*0.01;
	envAttack = hslider("v:clarinetMidi/[7]envAttack",1,0,30,0.01)*0.001;
	s = hslider("v:clarinetMidi/[8]sustain[hide:1][midi:ctrl 64]",0,0,1,1);
	t = button("v:clarinetMidi/[9]gate");

	gate = t+s : min(1);
	vibrato = 1+os.osc(vibratoFreq)*vibratoGain*envelope;
	freq = f*bend*vibrato;
	envelope = gate*gain : si.smooth(ba.tau2pole(envAttack));

	tubeLength = freq : f2l;
	pressure = envelope*vibrato;
	blow = blower(pressure,0.05,2000);
};

//=====================================Exciters===========================================
// Various kind of excitation signal generators.
//========================================================================================

//-------`impulseExcitation`--------------
// Creates an impulse excitation of one sample.
//
// #### Usage
//
// ```
// gate = button('gate');
// impulseExcitation(gate) : chain;
// ```
//
// Where:
//
// * `gatè`: a gate button
//--------------------------------------
impulseExcitation(trigger) = trigger : ba.impulsify;

//-------`blower`--------------
// A virtual blower creating a DC signal with some breath noise in it.
//
// #### Usage
//
// ```
// blower(pressure,breathGain,breathCutoff) : _
// ```
//
// Where:
//
// * `pressure`: pressure (0-1)
// * `breathGain`: breath noise gain (0-1) (recommended: 0.005)
// * `breathCutoff`: breath cuttoff frequency (Hz) (recommended: 2000)
//--------------------------------------
blower(pressure,breathGain,breathCutoff) = pressure + breathNoise
with{
	breathNoise = no.noise : fi.lowpass(2,breathCutoff) : *(pressure*breathGain);
};

//-------`blower_ui`--------------
// Same as [`blower`](#blower) but with a built-in UI.
//
// #### Usage
//
// ```
// blower : somethingToBeBlown
// ```
//--------------------------------------
blower_ui = blower(pressure,breathGain,breathCutoff)
with{
	pressure = hslider("v:blower/[0]pressure",0,0,1,0.01) : si.smoo;
	breathGain = hslider("v:blower/[1]breathGain",0.1,0,1,0.01)*0.05;
	breathCutoff = hslider("v:blower/[2]breathCutoff",2000,20,20000,0.1);
};




//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// OLD SECTIONS BEYOND THIS MARK
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

//-------idealString(length,reflexion,xPosition,x)----------
// An ideal string with rigid terminations and where the plucking position and the
// pick-up position are the same.
// ### Usage
// ```
// 1-1' : idealString(length,reflexion,xPosition,x)
// ```
// With:
// * `length`: the length of the string in meters
// * `reflexion`: the coefficient of reflexion (0-0.99999999)
// * `pluckPosition`: the plucking position (0.001-0.999)
// * `x`: the input signal for the excitation
// ### Requires
// `filter.lib` (`fdelay4`,`crossnn`)
//----------------------------------------------------------
idealString(length,reflexion,pluckPosition,x) = fullTerminations(term,wg,term)
with{
	nMax = 512; // each segment of the string can't be longer than that
	N = length*ma.SR/320-8; // length (meters) to samples
	nUp = N/2*pluckPosition : max(1); // upper string segment length
	nDown = N/2*(1-pluckPosition) : max(1); // lower string segment length
	wg = chain(waveguide(nMax,nUp) : input(x) : output : waveguide(nMax,nDown)); // waveguide chain
	term = *(-reflexion); // terminations
};

//-------dampingFilter(rho,h0,h1,x)--------------------
// TODO
//-----------------------------------------------------
dampingFilter(rho,h0,h1,x) = rho * (h0 * x' + h1*(x+x''));

//-------bridge(length,B,t60,x)-----------
// Simulate a bridge using a dampingFilter.
// ### Usage
// ```
//
// ```
// With:
// * `length`: length of the string in meters
// * `B`: the brightness of the string (0-0.99)
// * `t60̀: decaying time
// * `x`: the input signal for the excitation
// ### Requires
// `filter.lib`
//------------------------------------------------------
/*
bridge(length,B,t60,x) = dampingFilter(rho,h0,h1,x)
with{
	freq = 320/length;
	h0 = (1.0 + B)/2;
	h1 = (1.0 - B)/4;
	rho = pow(0.001,1.0/(freq*t60));
};
*/

//-------steelString-----------------------------
//-----------------------------------------------
steelString(length,pluckPosition,x) = fullTerminations(bridge,wg,bridge)
with{
	nMax = 512; // each segment of the string can't be longer than that
	N = length*SR/320-8; // length (meters) to samples
	nUp = N/2*pluckPosition : max(1); // upper string segment length
	nDown = N/2*(1-pluckPosition) : max(1); // lower string segment length
	wg = chain(waveguide(nMax,nUp) : input(x) : output : waveguide(nMax,nDown)); // waveguide chain
	bridge = bridge(length,B,t60,x)
	with{
		B = 0.8;
		t60 = 6;
	};
};

//-------nylonString-----------------------------
//-----------------------------------------------
nylonString(length,pluckPosition,B,t60,x) = fullTerminations(term,wg,term)
with{
	nMax = 512; // each segment of the string can't be longer than that
	N = length*SR/320-8; // length (meters) to samples
	nUp = N/2*pluckPosition : max(1); // upper string segment length
	nDown = N/2*(1-pluckPosition) : max(1); // lower string segment length
	wg = chain(waveguide(nMax,nUp) : input(x) : output : waveguide(nMax,nDown)); // waveguide chain

	term(x) = bridge(length,B,t60,x)
	with{
		B = 0.25;
		t60 = 4;
	};
};


//-------acousticExcitation(gate,P)-------------
// Creates an acoustic excitation (a noise burst) when a gate button is triggered.
// ### Usage
// ```
// gate = button('gate');
// P = SR/freq;
// acousticExcitation(gate,P) : chain;
// ```
// With:
// * `gatè: a gate button
// * `P̀ : fundamental period in samples
// ### Requires
// 'music.lib' (noise)
//--------------------------------------
acousticExcitation(gate,P) = no.noise : *(gate : trigger(P))
with {
     diffgtz(x) = (x-x') > 0;
     decay(n,x) = x-(x>0)/n;
     release(n) = + ~ decay(n);
     trigger(n) = diffgtz : release(n) : > (0.0);
};


//-----modeFilter-----
modeFilter(f,t60) = tf2(b0,b1,b2,a1,a2)
with{
	b0 = 1;
	b1 = 0;
	b2 = -1;
	w = 2*PI*f/SR;
	r = pow(0.001,1/float(t60*SR));
	a1 = -2*r*cos(w);
	a2 = r^2;
};

//---modalModel--
// modeFreqs : list of modal frequencies
// modeRes : list of t60 corresponding to the frequencies
// modeGains : list of gains corresponding to the frequencies
//--------------
modalModel(n,modeFreqs,modeRes,modeGains) = _ <: par(i,n,gain(i)*modeFilter(freqs(i),res(i))) :> _
with{
	freqs(i) = take(i+1,modeFreqs);
	res(i) = take(i+1,modeRes);
	gain(i) = take(i+1,modeGains);
};
