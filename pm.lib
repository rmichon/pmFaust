//##################################### physModels.lib ###################################
// Faust physical modeling library; Its official prefix is `pm`.
//
// This library provides an environment to facilitate physical modeling of musical
// instruments. It contains dozens of functions implementing low and high level
// elements going from a simple waveguide to fully operational models with
// built-in UI, etc.
// More information on how to use this library can be find at this page:
// <https://ccrma.stanford.edu/~rmichon/pmFaust>
//########################################################################################

import("stdfaust.lib");

/*
TODO:
	- It'd be cool to have a version of the block diagram generator that automatically flips
	things based on the use of chains, etc.
	- When setting pole of filters by hand (e.g. smooth, should adjust pole in function of SR)
	- Probably need a single resonator function / see how to integrate that with "mode"
	- Need a non-linear function and see how this can be integrated with modal synthesis
	- See how bowed modal models could be integarted to this
	- Currently still missing keyboard instruments
	- Currently still missing vocal synth: easy to fix (create a formant filter function)
*/

//=============================Global Variables===========================================
// Useful pre-defined variables for physical modeling.
//========================================================================================

//--------------`speedOfSound`----------
// Speed of sound in meters per second (340m/s).
//--------------------------------------
speedOfSound = 340;

//--------------`maxLength`----------
// The default maximum length (3) in meters of strings and tubes used in this
// library. This variable should be overriden allow longer strings or tubes.
//--------------------------------------
maxLength = 3;

//================================Conversion Tools=======================================
// Useful conversion tools for physical modeling.
//========================================================================================

//--------------`f2l`----------
// Frequency to lentgh in meters.
//
// #### Usage
//
// ```
// f2l(freq) : distanceInMeters
// ```
//
// Where:
//
// * `freq`: the frequency
//-------------------------------
f2l(freq) = speedOfSound/freq;

//--------------`l2f`----------
// Lentgh in meters to frequency.
//
// #### Usage
//
// ```
// l2f(length) : freq
// ```
//
// Where:
//
// * `length`: length/distance in meters
//-------------------------------
l2f(length) = speedOfSound/length;

//--------------`l2s`----------
// Length in meters to number of samples.
//
// #### Usage
//
// ```
// l2s(l) : numberOfSamples
// ```
//
// Where:
//
// * `l`: length in meters
//-------------------------------
l2s(l) = l*ma.SR/speedOfSound;

//=============================Bidirectional Utilities====================================
// Set of fundamental functions to create bi-directional block diagrams in Faust.
// These elements are used as the basis of this library to connect high level
// elements (e.g., mouthpieces, strings, bridge, instrument body, etc.). Each
// block has 3 inputs and 3 outputs. The first input/output carry left going
// waves, the second input/output carry right going waves, and the third
// input/output is used to carry any potential output signal to the end of the
// algorithm.
//========================================================================================

//--------------`basicBlock`----------
// Empty bidirectional block to be used with [`chain`](#chain): 3 signals ins
// and 3 signals out.
//
// #### Usage
//
// ```
// chain(basicBlock : basicBlock : etc.)
// ```
//-------------------------------
basicBlock = _,_,_;

//-------`chain`----------
// Creates a chain of bidirectional blocks.
// Blocks must have 3 inputs and outputs. The first input/output carry left
// going waves, the second input/output carry right going waves, and the third
// input/output is used to carry any potential output signal to the end of the
// algorithm. The implied one sample delay created by the `~` operator is
// generalized to the left and right going waves. Thus, `n` blocks in `chain()`
// will add an `n` samples delay to both left and right going waves.
//
// #### Usage
//
// ```
// rightGoingWaves,leftGoingWaves,mixedOutput : chain( A : B ) : rightGoingWaves,leftGoingWaves,mixedOutput
// with{
// 		A = _,_,_;
//		B = _,_,_;
// };
// ```
//-----------------------------
chain(A:As) = ((ro.crossnn(1),_',_ : _,A : ro.crossnn(1),_,_ : _,chain(As) : ro.crossnn(1),_,_)) ~ _ : !,_,_,_;
chain(A) = A;

//-------`inLeftWave`--------------
// Adds a signal to left going waves anywhere in a [`chain`](#chain) of blocks.
//
// #### Usage
//
// ```
// model(x) = chain(A : inLeftWave(x) : B)
// ```
//
// Where `A` and `B` are bidirectional blocks and `x` is the signal added to left
// going waves in that chain.
//--------------------------------
inLeftWave(x) = +(x),_,_;

//-------`inRightWave`--------------
// Adds a signal to right going waves anywhere in a [`chain`](#chain) of blocks.
//
// #### Usage
//
// ```
// model(x) = chain(A : inRightWave(x) : B)
// ```
//
// Where `A` and `B` are bidirectional blocks and `x` is the signal added to right
// going waves in that chain.
//--------------------------------
inRightWave(x) = _,+(x),_;

//-------`in`--------------
// Adds a signal to left and right going waves anywhere in a [`chain`](#chain)
// of blocks.
//
// #### Usage
//
// ```
// model(x) = chain(A : in(x) : B)
// ```
//
// Where `A` and `B` are bidirectional blocks and `x` is the signal added to
// left and right going waves in that chain.
//--------------------------------
in(x) = +(x),+(x),_;

//-------`outLeftWave`--------------
// Sends the signal of left going waves to the output channel of the [`chain`](#chain).
//
// #### Usage
//
// ```
// chain(A : outLeftWave : B)
// ```
//
// Where `A` and `B` are bidirectional blocks.
//--------------------------------
outLeftWave(x,y,s) = x,y,x+s;

//-------`outRightWave`--------------
// Sends the signal of right going waves to the output channel of the [`chain`](#chain).
//
// #### Usage
//
// ```
// chain(A : outRightWave : B)
// ```
//
// Where `A` and `B` are bidirectional blocks.
//--------------------------------
outRightWave(x,y,s) = x,y,y+s;

//-------`out`--------------
// Sends the signal of right and left going waves to the output channel of the
// [`chain`](#chain).
//
// #### Usage
//
// ```
// chain(A : out : B)
// ```
//
// Where `A` and `B` are bidirectional blocks.
//--------------------------------
out(x,y,s) = x,y,x+y+s;

//-------`terminations`--------------
// Creates terminations on both sides of a [`chain`](#chain) without closing
// the inputs and outputs of the bidirectional signals chain. As for
// [`chain`](#chain), this function adds a 1 sample delay to the bidirectional
// signal, both ways. Of courses, this function can be nested within a
// [`chain`](#chain).
//
// #### Usage
//
// ```
// terminations(a,b,c)
// with{
//		a = *(-1); // left termination
//		b = chain(D : E : F); // bidirectional chain of blocks (D, E, F, etc.)
//		c = *(-1); // right termination
// };
// ```
//----------------------------------------
terminations(a,b,c) = (_,ro.crossnn(1),_,_ : +,+,_ : b) ~ (a,c : ro.crossnn(1));

//-------`leftTermination`----------
// Creates a termination on the left side of a [`chain`](#chain) without
// closing the inputs and outputs of the bidirectional signals chain. This
// function adds a 1 sample delay near the termination and can be nested
// within another [`chain`](#chain).
//
// #### Usage
//
// ```
// leftTerminations(a,b)
// with{
//		a = *(-1); // left termination
//		b = chain(D : E : F); // bidirectional chain of blocks (D, E, F, etc.)
// };
// ```
//----------------------------------------
lTermination(a,b) = (ro.crossnn(1),_,_ : _,+,_ : b) ~ a;

//-------`rTermination`----------
// Creates a termination on the right side of a [`chain`](#chain) without
// closing the inputs and outputs of the bidirectional signals chain. This
// function adds a 1 sample delay near the termination and can be nested
// within another [`chain`](#chain).
//
// #### Usage
//
// ```
// rTerminations(b,c)
// with{
//		b = chain(D : E : F); // bidirectional chain of blocks (D, E, F, etc.)
//		c = *(-1); // right termination
// };
// ```
//----------------------------------------
rTermination(b,c) = (_,_,_,_ : +,_,_ : b) ~ (!,c);

//-------`closeIns`----------
// Closes the inputs of a bidirectional chain in all directions.
//
// #### Usage
//
// ```
// closeIns : chain(...) : 	_,_,_
// ```
//----------------------------------------
closeIns = 0,0,0;

//-------`closeOuts`----------
// Closes the outputs of a bidirectional chain in all directions except for the
// main signal output (3d output).
//
// #### Usage
//
// ```
// _,_,_ : chain(...) : _
// ```
//----------------------------------------
closeOuts = !,!,_;

//-------`endChain`----------
// Closes the inputs and outputs of a bidirectional chain in all directions
// except for the main signal output (3d output).
//
// #### Usage
//
// ```
// endChain(chain(...)) : _
// ```
//----------------------------------------
endChain(b) = closeIns : b : closeOuts;


//==================================Basic Elements========================================
// Basic elements for physical modeling (e.g., waveguides, specific filters,
// etc.).
//========================================================================================

//-------`waveguideN`----------
// A series of waveguide functions based on various types of delays (see
// [`fdelay[n]`](#fdelayn)).
//
// #### List of functions
//
// * `waveguideUd`: unit delay waveguide
// * `waveguideFd`: fractional delay waveguide
// * `waveguideFd2`: second order fractional delay waveguide
// * `waveguideFd4`: fourth order fractional delay waveguide
//
// #### Usage
//
// ```
// chain(A : waveguideUd(nMax,n) : B)
// ```
//
// Where:
//
// * `nMax`: the maximum length of the delays in the waveguide
// * `n`: the length of the delay lines in samples.
//----------------------------------
waveguideUd(nMax,n) = par(i,2,de.delay(nMax,n)),_;
waveguideFd(nMax,n) = par(i,2,de.fdelay(nMax,n)),_;
waveguideFd2(nMax,n) = par(i,2,de.fdelay2(nMax,n)),_;
waveguideFd4(nMax,n) = par(i,2,de.fdelay4(nMax,n)),_;

//-------`waveguide`----------
// Standard `pm.lib` waveguide (based on [`waveguideFd4`](#waveguiden)).
//
// #### Usage
//
// ```
// chain(A : waveguide(nMax,n) : B)
// ```
//
// Where:
//
// * `nMax`: the maximum length of the delays in the waveguide
// * `n`: the length of the delay lines in samples.
//----------------------------------
waveguide(nMax,n) = waveguideFd4(nMax,n);

//-------`bridgeFilter`----------
// "Generic" two zeros bridge FIR filter (as implemented in the
// [STK](https://ccrma.stanford.edu/software/stk/)) that can be used to
// implement the reflectance violin, guitar, etc. bridges.
//
// #### Usage
//
// ```
// _ : bridge(brightness,absorption) : _
// ```
//
// Where:
//
// * `brightness`: controls the damping of high frequencies (0-1)
// * `absorption`: controls the absorption of the brige and thus the t60 of
// the string plugged to it (0-1) (1 = 20 seconds)
//----------------------------------
// TODO: perhaps, the coefs of this filter should be adapted in function of SR
bridgeFilter(brightness,absorption) = rho * (h0 * x' + h1*(x+x''))
with{
	freq = 320;
  t60 = (1-absorption)*20;
	h0 = (1.0 + brightness)/2;
	h1 = (1.0 - brightness)/4;
	rho = pow(0.001,1.0/(freq*t60));
};

//========================Basic String Instruments Elements===============================
// Low and high level basic string instruments parts. Most of the elements in
// this section can be used in a bidirectional chain.
//========================================================================================

//-------`stringSegment`----------
// A string segment without terminations (jsut a simple waveguide).
//
// #### Usage
//
// ```
// chain(A : stringSegment(maxLength,length) : B)
// ```
//
// Where:
//
// * `maxLength`: the maximum length of the string in meters (should be static)
// * `length`: the length of the string in meters
//----------------------------------
stringSegment(maxLength,length) = waveguide(nMax,n)
with{
	nMax = maxLength : l2s;
	n = length : l2s/2;
};

//-------`openString`----------
// A bidirectional block implementing a basic "generic" string with a
// selectable excitation position. Lowpass filters are built-in and
// allow to simulate the effect of dispersion on the sound and thus
// to change the "stiffness" of the string.
//
// #### Usage
//
// ```
// chain(... : openString(length,stiffness,pluckPosition,excitation) : ...)
// ```
//
// Where:
//
// * `length`: the length of the string in meters
// * `stiffness`: the stiffness of the string (0-1) (1 for max stiffness)
// * `pluckPosition`: excitation position (0-1) (1 is bottom)
// * `excitation`: the excitation signal
//----------------------------------
openString(length,stiffness,pluckPosition,excitation) = chain(stringSegment(maxStringLength,ntbd) : in(excitation) : dispersionFilters : stringSegment(maxStringLength,btbd))
with{
  dispersionFilters = par(i,2,si.smooth(stiffness)),_; // one pole filters
  maxStringLength = maxLength;
  ntbd = length*pluckPosition; // length of the upper portion of the string
	btbd = length*(1-pluckPosition); // length of the lower portion of the string
};

//-------`nylonString`----------
// A bidirectional block implementing a basic nylon string with selectable
// excitation position. This element is based on [`openString`](#openstring)
// and has a fix stiffness corresponding to that of a nylon string.
//
// #### Usage
//
// ```
// chain(... : nylonString(length,pluckPosition,excitation) : ...)
// ```
//
// Where:
//
// * `length`: the length of the string in meters
// * `pluckPosition`: excitation position (0-1) (1 is bottom)
// * `excitation`: the excitation signal
//----------------------------------
nylonString(length,pluckPosition,excitation) =
openString(length,stiffness,pluckPosition,excitation)
with{
	stiffness = 0.4; // empirically set but it sounds good ;)
};

//-------`steelString`----------
// A bidirectional block implementing a basic nylon string with selectable
// excitation position. This element is based on [`openString`](#openstring)
// and has a fix stiffness corresponding to that of a steel string.
//
// #### Usage
//
// ```
// chain(... : steelString(length,pluckPosition,excitation) : ...)
// ```
//
// Where:
//
// * `length`: the length of the string in meters
// * `pluckPosition`: excitation position (0-1) (1 is bottom)
// * `excitation`: the excitation signal
//----------------------------------
steelString(length,pluckPosition,excitation) =
openString(length,stiffness,pluckPosition,excitation)
with{
	stiffness = 0.05; // empirically set but it sounds good ;)
	// in fact, we could almost get rid of the filters in that case,
	// but I think it's good to keep them for consistency
};

//-------`openStringPick`----------
// A bidirectional block implementing a "generic" string with selectable
// excitation position. It also has a built-in pickup whose position is the
// same as the excitation position. Thus, moving the excitation position
// will also move the pickup.
//
// #### Usage
//
// ```
// chain(... : openStringPick(length,stiffness,pluckPosition,excitation) : ...)
// ```
//
// Where:
//
// * `length`: the length of the string in meters
// * `stiffness`: the stiffness of the string (0-1) (1 for max stiffness)
// * `pluckPosition`: excitation position (0-1) (1 is bottom)
// * `excitation`: the excitation signal
//----------------------------------
openStringPick(length,stiffness,pluckPosition,excitation) = strChain
with{
  dispersionFilters = par(i,2,si.smooth(stiffness)),_;
  maxStringLength = maxLength;
  nti = length*pluckPosition; // length of the upper portion of the string
  itb = length*(1-pluckPosition); // length of the lower portion of the string
  strChain = chain(stringSegment(maxStringLength,nti) : in(excitation) : out :
	dispersionFilters : stringSegment(maxStringLength,itb));
};

//-------`openStringPickUp`----------
// A bidirectional block implementing a "generic" string with selectable
// excitation position and stiffness. It also has a built-in pickup whose
// position can be independenly selected. The only constraint is that the
// pickup has to be placed after the excitation position.
//
// #### Usage
//
// ```
// chain(... : openStringPickUp(length,stiffness,pluckPosition,excitation) : ...)
// ```
//
// Where:
//
// * `length`: the length of the string in meters
// * `stiffness`: the stiffness of the string (0-1) (1 for max stiffness)
// * `pluckPosition`: pluck position between the top of the string and the
// pickup (0-1) (1 for same as pickup position)
// * `pickupPosition`: position of the pickup on the string (0-1) (1 is bottom)
// * `excitation`: the excitation signal
//----------------------------------
openStringPickUp(length,stiffness,pluckPosition,pickupPosition,excitation) = strChain
with{
  dispersionFilters = par(i,2,si.smooth(stiffness)),_;
  maxStringLength = maxLength;
  nti = length*pluckPosition; // top to excitation length
  nto = nti*pickupPosition; // nuts to pickup length
  oti = nti*(1-pickupPosition); // pickup to excitation length
  itb = length*(1-pluckPosition); // pickup to bottom length
  strChain = chain(stringSegment(maxStringLength,nto) : out :
	stringSegment(maxStringLength,oti) : in(excitation) : dispersion :
	stringSegment(maxStringLength,itb));
};

//-------`openStringPickDown`----------
// A bidirectional block implementing a "generic" string with selectable
// excitation position and stiffness. It also has a built-in pickup whose
// position can be independenly selected. The only constraint is that the
// pickup has to be placed before the excitation position.
//
// #### Usage
//
// ```
// chain(... : openStringPickDown(length,stiffness,pluckPosition,excitation) : ...)
// ```
//
// Where:
//
// * `length`: the length of the string in meters
// * `stiffness`: the stiffness of the string (0-1) (1 for max stiffness)
// * `pluckPosition`: pluck position on the string (0-1) (1 is bottom)
// * `pickupPosition`: position of the pickup between the top of the string
// and the excitation position (0-1) (1 is excitation position)
// * `excitation`: the excitation signal
//----------------------------------
openStringPickDown(length,stiffness,pluckPosition,pickupPosition,excitation) =
strChain
with{
  dispersionFilters = par(i,2,si.smooth(stiffness)),_;
  maxStringLength = maxLength;
  nto = length*pickupPosition; // top to pickup length
  nti = nto*pluckPosition; // top to excitation length
  ito = nto*(1-pluckPosition); // excitation to pickup length
  otb = length*(1-pickupPosition); // pickup to bottom length
  strChain = chain(stringSegment(maxStringLength,nti) : in(excitation) :
	stringSegment(maxStringLength,ito) : out : dispersionFilters :
	stringSegment(maxStringLength,otb));
};

// TODO: eventually, we'd want to implement a generic function here that
// automatically switches the position of elements in the algorithm
// depending on the position of the pick. Even though this is currently
// possible, it will pose optimization issues (we'd want the new mute
// feature of Faust to be generalized in order to do that)

//-------`ksReflexionFilter`----------
// The "typical" one-zero Karplus-strong feedforward reflexion filter. This
// filter will be typically used in a termination (see below).
//
// #### Usage
//
// ```
// terminations(_,chain(...),ksReflexionFilter)
// ```
//----------------------------------
ksReflexionFilter = _ <: (_+_')/2;

//-------`rStringRigidTermination`----------
// Bidirectional block implementing a right rigid string termination (no damping,
// just phase inversion).
//
// #### Usage
//
// ```
// chain(rStringRigidTermination : stringSegment : ...)
// ```
//----------------------------------
rStringRigidTermination = rTermination(basicBlock,*(-1));

//-------`lStringRigidTermination`----------
// Bidirectional block implementing a left rigid string termination (no damping,
// just phase inversion).
//
// #### Usage
//
// ```
// chain(... : stringSegment : lStringRigidTermination)
// ```
//----------------------------------
lStringRigidTermination = lTermination(*(-1),basicBlock);

//-------`elecGuitarBridge`----------
// Bidirectional block implementing a simple electric guitar bridge. This
// block is based on [`bridgeFilter`](#bridgeFilter). The bridge doesn't
// implement transmittance since it is not meant to be connected to a
// body (unlike acoustic guitar). It also partially sets the resonance
// duration of the string with the nuts used on the other side.
//
// #### Usage
//
// ```
// chain(... : stringSegment : elecGuitarBridge)
// ```
//----------------------------------
elecGuitarBridge = rTermination(basicBlock,-bridgeFilter(0.8,0.5));

//-------`elecGuitarNuts`----------
// Bidirectional block implementing a simple electric guitar nuts. This
// block is based on [`bridgeFilter`](#bridgeFilter) and does essentially
// the same thing as [`elecGuitarBridge`](#elecguitarbridge), but on the
// other side of the chain. It also partially sets the resonance duration of
// the string with the bridge used on the other side.
//
// #### Usage
//
// ```
// chain(elecGuitarNuts : stringSegment : ...)
// ```
//----------------------------------
elecGuitarNuts = lTermination(-bridgeFilter(0.8,0.5),basicBlock);

//-------`guitarBridge`----------
// Bidirectional block implementing a simple acoustic guitar bridge. This
// bridge damps more hight frequencies than
// [`elecGuitarBridge`](#elecguitarbridge) and implements a transmittance
// filter. It also partially sets the resonance duration of the string with
// the nuts used on the other side.
//
// #### Usage
//
// ```
// chain(... : stringSegment : guitarBridge)
// ```
//----------------------------------
guitarBridge = rTermination(basicBlock,reflectance) : _,transmittance,_
with{
	reflectance = -bridgeFilter(0.4,0.5);
	transmittance = _; // TODO
};

//-------`guitarNuts`----------
// Bidirectional block implementing a simple acoustic guitar nuts. This
// nuts damps more hight frequencies than
// [`elecGuitarNuts`](#elecguitarnuts) and implements a transmittance
// filter. It also partially sets the resonance duration of the string with
// the bridge used on the other side.
//
// #### Usage
//
// ```
// chain(guitarNuts : stringSegment : ...)
// ```
//----------------------------------
guitarNuts = lTermination(-bridgeFilter(0.4,0.5),basicBlock);

//-------`ks`----------
// A karplus-strong string (in that case, the string is implemented as a
// one dimension waveguide).
//
// #### Usage
//
// ```
// ks(length,damping,excitation) : _
// ```
//
// Where:
//
// * `length`: the length of the string in meters
// * `damping`: string damping (0-1)
// * `excitation`: excitation signal
//----------------------------------
ks(length,damping,excitation) = endChain(ksChain)
with{
	maxStringLength = 1; // meters
	lengthTuning = 0.05;
	tunedLength = length-0.05;
	refCoef = (1-damping)*0.2+0.8;
	refFilter = ksReflexionFilter*refCoef;
	ksChain = terminations(_,chain(in(excitation) :
	stringSegment(maxStringLength,tunedLength) : out),refFilter);
};

//-------`ks_ui_MIDI`----------
// Ready-to-use MIDI-enabled karplus strong string with buil-in UI.
//
// #### Usage
//
// ```
// ks_ui_MIDI : _
// ```
//----------------------------------
ks_ui_MIDI = gate : impulseExcitation : ks( (freq:f2l), damping )
with{
	f = hslider("v:karplus/h:[0]params/[0]freq[style:knob]",440,50,1000,0.01);
	bend = hslider("v:karplus/h:[0]params/[1]bend[style:knob][hide:1][midi:pitchwheel]"
	,1,0,10,0.01) : si.polySmooth(gate,0.999,1);
	gain = hslider("v:karplus/h:[0]params/[2]gain[style:knob]",0.8,0,1,0.01);
	s = hslider("v:karplus/h:[0]params/[3]sustain[hide:1][midi:ctrl 64][style:knob]"
	,0,0,1,1);
	damping = hslider("v:karplus/h:[0]params/[1]damping[midi:ctrl 1][style:knob]"
	,0.01,0,1,0.01);
	t = button("v:karplus/[1]gate");

	gate = t+s : min(1);
	freq = f*bend;
};

//-------`basicElecGuitarModel`----------
// A simple electric guitar model (without audio effects, of course).
//
// #### Usage
//
// ```
// basicElecGuitarModel(length,pluckPosition,excitation) : _
// ```
//
// Where:
//
// * `length`: the length of the string in meters
// * `pluckPosition`: pluck position (0-1) (1 is on the bridge)
// * `excitation`: excitation signal
//----------------------------------
basicElecGuitarModel(length,pluckPosition,excitation) = endChain(egChain)
with{
  maxStringLength = 2; // meters
	lengthTuning = 0.11;
	stringL = length-lengthTuning;
  egChain = chain(elecGuitarNuts : openStringPick(stringL,0.05,pluckPosition,excitation) : elecGuitarBridge);
};

//-------`guitarBody`----------
// WARNING: not implemnted yet!
// Bidirectional block implementing a simple acoustic guitar body.
//
// #### Usage
//
// ```
// chain(... : guitarBody)
// ```
//----------------------------------
// TODO: not implemented yet
guitarBody = reflectance,transmittance,_
with{
	transmittance = _;
	reflectance = _;
};

//-------`basicGuitarModel`----------
// A simple acoustic guitar model with steel strings.
//
// #### Usage
//
// ```
// basicGuitarModel(length,pluckPosition,excitation) : _
// ```
//
// Where:
//
// * `length`: the length of the string in meters
// * `pluckPosition`: pluck position (0-1) (1 is on the bridge)
// * `excitation`: excitation signal
//----------------------------------
basicGuitarModel(length,pluckPosition,excitation) = endChain(egChain)
with{
  maxStringLength = 1; // meters
	lengthTuning = 1;
	stringL = length*lengthTuning;
  egChain = chain(guitarNuts : steelString(stringL,pluckPosition,excitation) : guitarBridge : guitarBody : out);
};

//-------`basicNylonGuitarModel`----------
// A simple acoustic guitar model with nylon strings.
//
// #### Usage
//
// ```
// basicNylonGuitarModel(length,pluckPosition,excitation) : _
// ```
//
// Where:
//
// * `length`: the length of the string in meters
// * `pluckPosition`: pluck position (0-1) (1 is on the bridge)
// * `excitation`: excitation signal
//----------------------------------
basicNylonGuitarModel(length,pluckPosition,excitation) = endChain(egChain)
with{
  maxStringLength = 1; // meters
	lengthTuning = 1;
	stringL = length*lengthTuning;
  egChain = chain(guitarNuts : nylonString(stringL,pluckPosition,excitation) : guitarBridge : guitarBody : out);
};

//-------`basicElecGuitar`----------
// A simple acoustic guitar model with steel strings implementing an excitation model.
//
// #### Usage
//
// ```
// basicElecGuitar(length,pluckPosition,trigger) : _
// ```
//
// Where:
//
// * `length`: the length of the string in meters
// * `pluckPosition`: pluck position (0-1) (1 is on the bridge)
// * `trigger`: trigger signal (1 for on, 0 for off)
//----------------------------------
basicElecGuitar(stringLength,pluckPosition,trigger) =
pluckString(stringLength,1,1,1,trigger) : basicElecGuitarModel(stringLength, pluckPosition);

//-------`basicGuitar`----------
// A simple acoustic guitar model with steel strings implementing an excitation model.
//
// #### Usage
//
// ```
// basicGuitar(length,pluckPosition,trigger) : _
// ```
//
// Where:
//
// * `length`: the length of the string in meters
// * `pluckPosition`: pluck position (0-1) (1 is on the bridge)
// * `trigger`: trigger signal (1 for on, 0 for off)
//----------------------------------
basicGuitar(stringLength,pluckPosition,trigger) =
pluckString(stringLength,1,1.5,1,trigger) : basicGuitarModel(stringLength, pluckPosition);

//-------`basicNylonGuitar`----------
// A simple acoustic guitar model with nylon strings implementing an excitation model.
//
// #### Usage
//
// ```
// basicNylonGuitar(length,pluckPosition,trigger) : _
// ```
//
// Where:
//
// * `length`: the length of the string in meters
// * `pluckPosition`: pluck position (0-1) (1 is on the bridge)
// * `trigger`: trigger signal (1 for on, 0 for off)
//----------------------------------
basicNylonGuitar(stringLength,pluckPosition,trigger) =
pluckString(stringLength,1,1.5,1,trigger) : basicNylonGuitarModel(stringLength, pluckPosition);

//-------`basicElecGuitar_ui_MIDI`----------
// Ready-to-use MIDI-enabled electric guitar physical model with built-in UI.
//
// #### Usage
//
// ```
// basicElecGuitar_ui_MIDI : _
// ```
//----------------------------------
basicElecGuitar_ui_MIDI = basicElecGuitar(stringLength,pluckPosition,gate)*outGain
with{
	f = hslider("v:basicElecGuitar/v:[0]midi/[0]freq",440,50,1000,0.01);
	bend = hslider("v:basicElecGuitar/v:[0]midi/[1]bend[hide:1][midi:pitchwheel]",1,0,10,0.01) : si.polySmooth(gate,0.999,1);
	gain = hslider("v:basicElecGuitar/v:[0]midi/[2]gain",0.8,0,1,0.01);
	s = hslider("v:basicElecGuitar/v:[0]midi/[3]sustain[hide:1][midi:ctrl 64]",0,0,1,1);
	t = button("v:basicElecGuitar/v:[0]midi/[4]gate");
  pluckPosition = hslider("v:basicElecGuitar/pluckPosition",0.8,0,1,0.01);
  outGain = hslider("v:basicElecGuitar/outGain",0.5,0,1,0.01);
	gate = t+s : min(1);
	freq = f*bend;
  stringLength = freq : f2l;
};

//-------`basicGuitar_ui_MIDI`----------
// Ready-to-use MIDI-enabled steel strings acoustic guitar physical model with built-in UI.
//
// #### Usage
//
// ```
// basicGuitar_ui_MIDI : _
// ```
//----------------------------------
basicGuitar_ui_MIDI = basicGuitar(stringLength,pluckPosition,gate)*outGain
with{
	f = hslider("v:basicGuitar/v:[0]midi/[0]freq",440,50,1000,0.01);
	bend = hslider("v:basicGuitar/v:[0]midi/[1]bend[hide:1][midi:pitchwheel]",1,0,10,0.01) : si.polySmooth(gate,0.999,1);
	gain = hslider("v:basicGuitar/v:[0]midi/[2]gain",0.8,0,1,0.01);
	s = hslider("v:basicGuitar/v:[0]midi/[3]sustain[hide:1][midi:ctrl 64]",0,0,1,1);
	t = button("v:basicGuitar/v:[0]midi/[4]gate");
  pluckPosition = hslider("v:basicGuitar/pluckPosition",0.8,0,1,0.01);
  outGain = hslider("v:basicGuitar/outGain",0.5,0,1,0.01);
	gate = t+s : min(1);
	freq = f*bend;
  stringLength = freq : f2l;
};

//-------`basicNylonGuitar_ui_MIDI`----------
// Ready-to-use MIDI-enabled nylon strings acoustic guitar physical model with built-in UI.
//
// #### Usage
//
// ```
// basicNylonGuitar_ui_MIDI : _
// ```
//----------------------------------
basicNylonGuitar_ui_MIDI = basicNylonGuitar(stringLength,pluckPosition,gate)*outGain
with{
	f = hslider("v:basicNylonGuitar/v:[0]midi/[0]freq",440,50,1000,0.01);
	bend = hslider("v:basicNylonGuitar/v:[0]midi/[1]bend[hide:1][midi:pitchwheel]",1,0,10,0.01) : si.polySmooth(gate,0.999,1);
	gain = hslider("v:basicNylonGuitar/v:[0]midi/[2]gain",0.8,0,1,0.01);
	s = hslider("v:basicNylonGuitar/v:[0]midi/[3]sustain[hide:1][midi:ctrl 64]",0,0,1,1);
	t = button("v:basicNylonGuitar/v:[0]midi/[4]gate");
  pluckPosition = hslider("v:basicNylonGuitar/pluckPosition",0.8,0,1,0.01);
  outGain = hslider("v:basicNylonGuitar/outGain",0.5,0,1,0.01);
	gate = t+s : min(1);
	freq = f*bend;
  stringLength = freq : f2l;
};

//=========================Bowed String Instruments Elements==============================
// Low and high level bowed string instruments parts.
//========================================================================================

//-------`bowTable`----------
// Extremely basic bow table that can be used to implement a wide range of
// bow types for many different bowed string instruments (violin, cello, etc.)
//
// #### Usage
//
// ```
// excitation : bowTable(offeset,slope) : _
// ```
//
// Where:
//
// * `excitation`: an excitation signal
// * `offset`: table offset
// * `slope`: table slope
//----------------------------------
bowTable(offset,slope) = pow(abs(sample) + 0.75, -4) : min(1)
with{
	sample = +(offset)*slope;
};


//-------`violinBow`----------
// Violin bow based on [`bowTable`](#bowtable).
//
// #### Usage
//
// ```
// bowVelocity : violinBow(bowPressure) : _
// ```
//
// Where:
//
// * `bowVelocity`: velocity of the bow/excitation signal (0-1)
// * `bowPressure`: bow pressure on the string (0-1)
//----------------------------------
violinBow(bowPressure) = bowTable(0,tableSlope)
with{
	tableSlope = 5 - (4*bowPressure);
};

//-------`bowInteraction`----------
// Bidirectional block implementing the interaction of a bow in a
// [`chain`](#chain).
//
// #### Usage
//
// ```
// chain(... : stringSegment : bowInteraction(bow) : stringSegment : ...)
// ```
//
// Where:
//
// * `bow`: the bow
//----------------------------------
bowInteraction(b) = (_,_ <: b,_,_ :> _,_),_;

//-------`violinBowInteraction`----------
// Bidirectional block implementing a violin bow interaction.
//
// #### Usage
//
// ```
// chain(... : stringSegment : violinBowInteraction(bowPressure,bowVelocity) : stringSegment : ...)
// ```
//
// Where:
//
// * `bowVelocity`: velocity of the bow / excitation signal (0-1)
// * `bowPressure`: bow pressure on the string (0-1)
//----------------------------------
violinBowInteraction(bowPressure,bowVelocity) = bowInteraction(bowSystem)
with{
	bowSystem = + : bowVelocity-_ <: *(violinBow(bowPressure)) <: _,_;
};

//-------`violinBowedString`----------
// Violin bowed string bidirectional block. Terminations are not implemented
// in this model
//
// #### Usage
//
// ```
// chain(nuts : violinBowedString(stringLength,bowPressure,bowVelocity,bowPosition) : bridge)
// ```
//
// Where:
//
// * `stringLength`: the length of the string in meters
// * `bowVelocity`: velocity of the bow / excitation signal (0-1)
// * `bowPressure`: bow pressure on the string (0-1)
// * `bowPosition`: the position of the bow on the string (0-1)
//----------------------------------
violinBowedString(stringLength,bowPressure,bowVelocity,bowPosition) =
	chain(
		stringSegment(maxStringLength,ntbd) :
		violinBowInteraction(bowPressure,bowVelocity) :
		stringSegment(maxStringLength,btbd)
	)
with{
	maxStringLength = 1; // meters
	ntbd = stringLength*bowPosition;
	btbd = stringLength*(1-bowPosition);
};

//-------`violinNuts`----------
// Dirt simple implementation of a violin "nuts": rigid termination.
//
// #### Usage
//
// ```
// chain(violinNuts : stringSegment : ...)
// ```
//----------------------------------
violinNuts = lStringRigidTermination;

//-------`violinBridge`----------
// Bidirectional block implementing a simple violin bridge.
//
// #### Usage
//
// ```
// chain(... : stringSegment : violinBridge
// ```
//----------------------------------
// TODO:
// 	* reflectance is not implemented yet
violinBridge = rTermination(basicBlock,reflectance) : _,transmittance,_
with{
	reflectance = -bridgeFilter(0.2,0.9);
	transmittance = _;
};

//-------`violinBody`----------
// Bidirectional block implementing a simple violin body.
//
// #### Usage
//
// ```
// chain(... : stringSegment : violinBridge : violinBody)
// ```
//----------------------------------
// TODO:
// 	* reflectance is not implemented yet
violinBody = reflectance,transmittance,_
with{
	transmittance = fi.resonbp(500,2,1);
	reflectance = _;
};

//-------`basicViolinModel`----------
// Ready-to-use basic violin physical model.
//
// #### Usage
//
// ```
// basicViolinModel(stringLength,bowPressure,bowVelocity,bridgeReflexion,bridgeAbsorption,bowPosition) : _
// ```
//
// Where:
//
// * `stringLength`: the length of the string in meters
// * `bowVelocity`: velocity of the bow / excitation signal (0-1)
// * `bowPressure`: bow pressure on the string (0-1))
// * `bowPosition`: the position of the bow on the string (0-1)
//----------------------------------
basicViolinModel(stringLength,bowPressure,bowVelocity,bowPosition) =
	endChain(modelChain)
with{
	stringTuning = 0.95;
	stringL = stringLength*stringTuning;
	modelChain = chain(
		violinNuts :
		violinBowedString(stringL,bowPressure,bowVelocity,bowPosition) :
		violinBridge :
		violinBody :
		out
	);
};

//-------`basicViolinModel_ui`----------
// Ready-to-use violin physical model with built-in UI.
//
// #### Usage
//
// ```
// basicViolinModel_ui : _
// ```
//----------------------------------
basicViolin_ui = basicViolinModel(stringLength,bowPress,bowVel,bowPos)*outGain
with{
	stringLength = hslider("v:violinModel/v:[0]string/[0]length",0.75,0,1,0.01);
	bowVel = hslider("v:violinModel/v:[1]bow/[0]velocity",0,0,1,0.01) : si.smoo;
	bowPress = hslider("v:violinModel/v:[1]bow/[1]pressure",0.5,0,1,0.01);
	bowPos = hslider("v:violinModel/v:[1]bow/[2]position",0.7,0,1,0.01);
	outGain = hslider("v:violinModel/outGain",0.5,0,1,0.01);
};

//-------`basicViolinModel_ui_MIDI`----------
// Ready-to-use MIDI-enabled violin physical model with built-in UI.
//
// #### Usage
//
// ```
// basicViolinModel_ui_MIDI : _
// ```
//----------------------------------
basicViolin_ui_MIDI = basicViolinModel(stringLength,bowPress,bowVel,bowPos)*outGain
with{
	f = hslider("v:violinModel/v:[0]midi/[0]freq",440,50,1000,0.01);
	bend = hslider("v:violinModel/v:[0]midi/[1]bend[hide:1][midi:pitchwheel]",1,0,10,0.01) : si.polySmooth(gate,0.999,1);
	gain = hslider("v:violinModel/v:[0]midi/[2]gain",0.6,0,1,0.01); // TODO: this might need some tuning
	envAttack = hslider("v:violinModel/v:[0]midi/[3]envAttack",1,0,30,0.01)*0.001;
	s = hslider("v:violinModel/v:[0]midi/[4]sustain[hide:1][midi:ctrl 64]",0,0,1,1);
	t = button("v:violinModel/v:[0]midi/[5]gate");
	bowPress = hslider("v:violinModel/v:[1]bow/[0]pressure",0.5,0,1,0.01);
	bowPos = hslider("v:violinModel/v:[1]bow/[1]position",0.7,0,1,0.01);
	vibratoFreq = hslider("v:violinModel/v:[2]vibrato/[0]frequency",6,1,10,0.01);
	vibratoGain = hslider("v:violinModel/v:[2]vibrato/[1]gain",0.5,0,1,0.01)*0.01;
	outGain = hslider("v:violinModel/outGain",0.5,0,1,0.01);

	gate = t+s : min(1);
	vibrato = 1+os.osc(vibratoFreq)*vibratoGain*envelope;
	freq = f*bend*vibrato;
	envelope = gate*gain : si.smooth(ba.tau2pole(envAttack));

	stringLength = freq : f2l;
	bowVel = envelope;
};

//===========================Wind Instrument Elements=====================================
// Low and high level wind instrument parts.
//========================================================================================

//-------`openTube`----------
// A tube segment without terminations (same as [`stringSegment`](#stringsegment)).
//
// #### Usage
//
// ```
// chain(A : openTube(maxLength,length) : B)
// ```
//
// Where:
//
// * `maxLength`: the maximum length of the tube in meters (should be static)
// * `length`: the length of the tube in meters
//----------------------------------
openTube = stringSegment;

//-------`reedTable`----------
// Extremely basic reed table that can be used to implement a wide range of
// single reed types for many different instruments (saxophone, clarinet, etc.)
//
// #### Usage
//
// ```
// excitation : reedTable(offeset,slope) : _
// ```
//
// Where:
//
// * `excitation`: an excitation signal
// * `offset`: table offset
// * `slope`: table slope
//----------------------------------
reedTable(offset,slope) = reedTable : min(1) : max(-1)
with {
	reedTable = *(slope) + offset;
};

//-------`fluteJetTable`----------
// Extremely basic flute jet table.
//
// #### Usage
//
// ```
// excitation : fluteJetTable : _
// ```
//
// Where:
//
// * `excitation`: an excitation signal
//----------------------------------
fluteJetTable = _ <: *(* : -(1)) : clipping
with{
  clipping = min(1) : max(-1);
};

//-------`clarinetReed`----------
// Clarinet reed based on [`reedTable`](#reedtable).
//
// #### Usage
//
// ```
// excitation : clarinetReed(stiffness) : _
// ```
//
// Where:
//
// * `excitation`: an excitation signal
// * `stiffness`: reed stiffness (0-1)
//----------------------------------
clarinetReed(stiffness) = reedTable(0.7,tableSlope)
with{
	tableSlope = -0.44 + 0.26*stiffness;
};

//-------`clarinetMouthPiece`----------
// Bidirectional block implementing a clarinet mouthpiece as well as the various
// interactions happening with traveling waves. This element is ready to be
// plugged to a tube...
//
// #### Usage
//
// ```
// chain(clarinetMouthPiece(reedStiffness,pressure) : tube : etc.)
// ```
//
// Where:
//
// * `pressure`: the pressure of the air flow created by the virtual performer (0-1).
// This can also be any kind of signal that will directly injected in the mouthpiece
// (e.g., breath noise, etc.)
// * `reedStiffness`: reed stiffness (0-1)
//----------------------------------
// TODO potentially, this function should be broken appart the same way we did it for bow
// and bowInteraction
clarinetMouthPiece(reedStiffness,pressure) = lTermination(reedInteraction,in(pressure))
with{
	reedInteraction = *(-1) <: *(clarinetReed(reedStiffness));
};

//-------`wBell`----------
// Generic wind instrument bell bidirectional block that should be placed at
// the end of a [`chain`](#chain).
//
// #### Usage
//
// ```
// chain(... : wBell(opening))
// ```
//
// Where:
//
// * `opening`: the opening of bell (0-1)
//----------------------------------
// TODO: perhaps should reverse this
wBell(opening) = rTermination(basicBlock,si.smooth(opening));

//-------`basicClarinetModel`----------
// A basic clarinet physical model.
//
// #### Usage
//
// ```
// basicClarinetModel(length,pressure,reedStiffness,bellOpening) : _
// ```
//
// Where:
//
// * `tubeLength`: the length of the tube in meters
// * `pressure`: the pressure of the air flow created by the virtual performer (0-1).
// This can also be any kind of signal that will directly injected in the mouthpiece
// (e.g., breath noise, etc.)
// * `reedStiffness`: reed stiffness (0-1)
// * `bellOpening`: the opening of bell (0-1)
//----------------------------------
basicClarinetModel(tubeLength,pressure,reedStiffness,bellOpening) = endChain(modelChain)
with{
	lengthTuning = 0.95; // empirical adjustment of the tuning of the tube
	maxTubeLength = 1; // meters
	tunedLength = tubeLength*lengthTuning;
	modelChain =
		chain(
			clarinetMouthPiece(reedStiffness,pressure) :
			openTube(maxTubeLength,tunedLength) :
			wBell(bellOpening) : out
		);
};

//-------`basicClarinetModel_ui`----------
// Same as [`basicClarinetModel`](#basicClarinetModel) but with a built-in UI.
//
// #### Usage
//
// ```
// basicClarinetModel_ui(pressure) : _
// ```
//
// Where:
//
// * `pressure`: the pressure of the air flow created by the virtual performer (0-1).
// This can also be any kind of signal that will directly injected in the mouthpiece
// (e.g., breath noise, etc.)
//----------------------------------
basicClarinetModel_ui(pressure) = basicClarinetModel(tubeLength,pressure,reedStiffness,bellOpening)*outGain
with{
	tubeLength = hslider("v:clarinetModel/[0]tubeLength",0.8,0.01,3,0.01) : si.smoo;
	reedStiffness = hslider("v:clarinetModel/[1]reedStiffness",0.5,0,1,0.01);
	bellOpening = hslider("v:clarinetModel/[2]bellOpening",0.5,0,1,0.01);
	outGain = hslider("v:clarinetModel/[3]outGain",0.5,0,1,0.01);
};

//-------`basicClarinet_ui`----------
// Ready-to-use clarinet physical model with built-in UI.
//
// #### Usage
//
// ```
// basicClarinet_ui : _
// ```
//----------------------------------
basicClarinet_ui = hgroup("clarinet",blower_ui : basicClarinetModel_ui);

//-------`basicClarinet_ui_MIDI`----------
// Ready-to-use MIDI compliant clarinet physical model with built-in UI.
//
// #### Usage
//
// ```
// basicClarinet_ui_MIDI : _
// ```
//----------------------------------
// TODO: missing outGain
basicClarinet_ui_MIDI =  basicClarinetModel(tubeLength,blow,reedStiffness,bellOpening)
with{
	f = hslider("v:clarinetMidi/[0]freq",440,50,1000,0.01);
	bend = hslider("v:clarinetMidi/[1]bend[hide:1][midi:pitchwheel]",1,0,10,0.01) : si.polySmooth(gate,0.999,1);
	gain = hslider("v:clarinetMidi/[2]gain",0.6,0,1,0.01);
	reedStiffness = hslider("v:clarinetMidi/[3]reedStiffness[midi:ctrl 1]",0.5,0,1,0.01);
	bellOpening = hslider("v:clarinetMidi/[4]bellOpening[midi:ctrl 3]",0.5,0,1,0.01);
	vibratoFreq = hslider("v:clarinetMidi/[5]vibratoFreq",5,1,10,0.01);
	vibratoGain = hslider("v:clarinetMidi/[6]vibratoGain",0.25,0,1,0.01)*0.01;
	envAttack = hslider("v:clarinetMidi/[7]envAttack",1,0,30,0.01)*0.001;
	s = hslider("v:clarinetMidi/[8]sustain[hide:1][midi:ctrl 64]",0,0,1,1);
	t = button("v:clarinetMidi/[9]gate");

	gate = t+s : min(1);
	vibrato = 1+os.osc(vibratoFreq)*vibratoGain*envelope;
	freq = f*bend*vibrato;
	envelope = gate*gain : si.smooth(ba.tau2pole(envAttack));

	tubeLength = freq : f2l;
	pressure = envelope*vibrato; // TODO: double vibrato here!!
	blow = blower(pressure,0.05,2000,vibratoFreq,vibratoGain);
};

//=====================================Exciters===========================================
// Various kind of excitation signal generators.
//========================================================================================

//-------`impulseExcitation`--------------
// Creates an impulse excitation of one sample.
//
// #### Usage
//
// ```
// gate = button('gate');
// impulseExcitation(gate) : chain;
// ```
//
// Where:
//
// * `gatè`: a gate button
//--------------------------------------
impulseExcitation(trigger) = trigger : ba.impulsify;

//-------`pluckString`--------------
// Creates a plucking excitation signal.
//
// #### Usage
//
// ```
// trigger = button('gate');
// pluckString(stringLength,cutoff,maxFreq,sharpness,trigger)
// ```
//
// Where:
//
// * `stringLength`: length of the string to pluck
// * `cutoff`: cutoff ratio (1 for default)
// * `maxFreq`: max frequency ratio (1 for default)
// * `sharpness`: sharpness of the attack and release (1 for default)
// * `trigger`: trigger signal (1 for on, 0 for off)
//--------------------------------------
pluckString(stringLength,cutoff,maxFreq,sharpness,trigger) = no.noise : fi.lowpass(2,cutoffreq) : *(en.ar(att,rel,trigger))
with{
  freq = stringLength : l2f;
  maxF = 2000*maxFreq;
  att = 0.002*sharpness*pow((1 - freq/maxF),2);
  rel = att;
  cutoffreq = freq*5*cutoff;
};

//-------`blower`--------------
// A virtual blower creating a DC signal with some breath noise in it.
//
// #### Usage
//
// ```
// blower(pressure,breathGain,breathCutoff) : _
// ```
//
// Where:
//
// * `pressure`: pressure (0-1)
// * `breathGain`: breath noise gain (0-1) (recommended: 0.005)
// * `breathCutoff`: breath cuttoff frequency (Hz) (recommended: 2000)
//--------------------------------------
blower(pressure,breathGain,breathCutoff,vibratoFreq,vibratoGain) = pressure + vibrato + breathNoise
with{
	vibrato = os.osc(vibratoFreq)*vibratoGain;
	breathNoise = no.noise : fi.lowpass(2,breathCutoff) : *(pressure*breathGain);
};

//-------`blower_ui`--------------
// Same as [`blower`](#blower) but with a built-in UI.
//
// #### Usage
//
// ```
// blower : somethingToBeBlown
// ```
//--------------------------------------
blower_ui = blower(pressure,breathGain,breathCutoff,vibratoFreq,vibratoGain)
with{
	pressure = hslider("v:blower/[0]pressure",0,0,1,0.01) : si.smoo;
	breathGain = hslider("v:blower/[1]breathGain",0.1,0,1,0.01)*0.05;
	breathCutoff = hslider("v:blower/[2]breathCutoff",2000,20,20000,0.1);
	vibratoFreq = hslider("v:blower/[3]vibratoFreq",5,0.1,10,0.1);
	vibratoGain = hslider("v:blower/[4]vibratoGain",0.25,0,1,0.01)*0.03;
};




//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// OLD SECTIONS BEYOND THIS MARK
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

//-------idealString(length,reflexion,xPosition,x)----------
// An ideal string with rigid terminations and where the plucking position and the
// pick-up position are the same.
// ### Usage
// ```
// 1-1' : idealString(length,reflexion,xPosition,x)
// ```
// With:
// * `length`: the length of the string in meters
// * `reflexion`: the coefficient of reflexion (0-0.99999999)
// * `pluckPosition`: the plucking position (0.001-0.999)
// * `x`: the input signal for the excitation
// ### Requires
// `filter.lib` (`fdelay4`,`crossnn`)
//----------------------------------------------------------
idealString(length,reflexion,pluckPosition,x) = fullTerminations(term,wg,term)
with{
	nMax = 512; // each segment of the string can't be longer than that
	N = length*ma.SR/320-8; // length (meters) to samples
	nUp = N/2*pluckPosition : max(1); // upper string segment length
	nDown = N/2*(1-pluckPosition) : max(1); // lower string segment length
	wg = chain(waveguide(nMax,nUp) : input(x) : output : waveguide(nMax,nDown)); // waveguide chain
	term = *(-reflexion); // terminations
};


//-------bridge(length,B,t60,x)-----------
// Simulate a bridge using a dampingFilter.
// ### Usage
// ```
//
// ```
// With:
// * `length`: length of the string in meters
// * `B`: the brightness of the string (0-0.99)
// * `t60̀: decaying time
// * `x`: the input signal for the excitation
// ### Requires
// `filter.lib`
//------------------------------------------------------
/*
bridge(length,B,t60,x) = dampingFilter(rho,h0,h1,x)
with{
	freq = 320/length;
	h0 = (1.0 + B)/2;
	h1 = (1.0 - B)/4;
	rho = pow(0.001,1.0/(freq*t60));
};
*/

//-------steelString-----------------------------
//-----------------------------------------------
/*
steelString(length,pluckPosition,x) = fullTerminations(bridge,wg,bridge)
with{
	nMax = 512; // each segment of the string can't be longer than that
	N = length*SR/320-8; // length (meters) to samples
	nUp = N/2*pluckPosition : max(1); // upper string segment length
	nDown = N/2*(1-pluckPosition) : max(1); // lower string segment length
	wg = chain(waveguide(nMax,nUp) : input(x) : output : waveguide(nMax,nDown)); // waveguide chain
	bridge = bridge(length,B,t60,x)
	with{
		B = 0.8;
		t60 = 6;
	};
};
*/

//-------nylonString-----------------------------
//-----------------------------------------------
/*
nylonString(length,pluckPosition,B,t60,x) = fullTerminations(term,wg,term)
with{
	nMax = 512; // each segment of the string can't be longer than that
	N = length*SR/320-8; // length (meters) to samples
	nUp = N/2*pluckPosition : max(1); // upper string segment length
	nDown = N/2*(1-pluckPosition) : max(1); // lower string segment length
	wg = chain(waveguide(nMax,nUp) : input(x) : output : waveguide(nMax,nDown)); // waveguide chain

	term(x) = bridge(length,B,t60,x)
	with{
		B = 0.25;
		t60 = 4;
	};
};
*/

//-------acousticExcitation(gate,P)-------------
// Creates an acoustic excitation (a noise burst) when a gate button is triggered.
// ### Usage
// ```
// gate = button('gate');
// P = SR/freq;
// acousticExcitation(gate,P) : chain;
// ```
// With:
// * `gatè: a gate button
// * `P̀ : fundamental period in samples
// ### Requires
// 'music.lib' (noise)
//--------------------------------------
acousticExcitation(gate,P) = no.noise : *(gate : trigger(P))
with {
     diffgtz(x) = (x-x') > 0;
     decay(n,x) = x-(x>0)/n;
     release(n) = + ~ decay(n);
     trigger(n) = diffgtz : release(n) : > (0.0);
};


//-----modeFilter-----
modeFilter(f,t60) = tf2(b0,b1,b2,a1,a2)
with{
	b0 = 1;
	b1 = 0;
	b2 = -1;
	w = 2*PI*f/SR;
	r = pow(0.001,1/float(t60*SR));
	a1 = -2*r*cos(w);
	a2 = r^2;
};

//---modalModel--
// modeFreqs : list of modal frequencies
// modeRes : list of t60 corresponding to the frequencies
// modeGains : list of gains corresponding to the frequencies
//--------------
modalModel(n,modeFreqs,modeRes,modeGains) = _ <: par(i,n,gain(i)*modeFilter(freqs(i),res(i))) :> _
with{
	freqs(i) = take(i+1,modeFreqs);
	res(i) = take(i+1,modeRes);
	gain(i) = take(i+1,modeGains);
};
