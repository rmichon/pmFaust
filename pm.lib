// # `pm.lib`: Physical Modeling Library

import("stdfaust.lib");

/*
TODO:
	- It'd be cool to have a version of the block diagram generator that automatically flips
	things based on the use of chains, etc.
	-
*/

//=============================Global Variables===========================================
// Useful pre-defined variables for physical modeling.
//========================================================================================

//--------------`speedOfSound`----------
// Speed of sound in meters per second (340m/s).
//--------------------------------------
speedOfSound = 340;

//================================Conversion Tools=======================================
// Useful conversion tools for physical modeling.
//========================================================================================

//--------------`f2l`----------
// Frequency to lentgh in meters.
//
// #### Usage
//
// ```
// f2l(freq) : distanceInMeters
// ```
//
// Where:
//
// * `freq`: the frequency
//-------------------------------
f2l(freq) = speedOfSound/freq;

//--------------`l2s`----------
// Length in meters to number of samples.
//
// #### Usage
//
// ```
// l2s(l) : numberOfSamples
// ```
//
// Where:
//
// * `l`: length in meters
//-------------------------------
l2s(l) = l*ma.SR/speedOfSound;

//=============================Bidirectional Utilities====================================
// Set of fundamental functions to create bi-directional block diagrams in Faust.
// These elements are used as the basis of this library.
//========================================================================================

//--------------`basicBlock`----------
// Empty bidirectional block to be used with [`chain`](#chain): 3 signals ins and 3 signals out.
//
// #### Usage
//
// ```
// chain(basicBlock : basicBlock : etc.)
// ```
//-------------------------------
basicBlock = _,_,_;

//-------`chain`----------
// Creates a chain of bidirectional blocks.
// Blocks must have 3 inputs and outputs. The first input/output correspond to the left
// going signal, the second input/output correspond to the right going signal and the
// third input/output is the mix of the main signal output. The implied one sample delay
// created by the `~` operator is generalized to the left and right going waves. Thus, n
// blocks in `chain()` will add an n samples delay to both the left and right going waves.
//
// #### Usage
//
// ```
// rightGoingWaves,leftGoingWaves,mixedOutput : chain(A:B) : rightGoingWaves,leftGoingWaves,mixedOutput
// with{
// 		A = _,_,_;
//		B = _,_,_;
// };
// ```
//-----------------------------
chain(A:As) = ((ro.crossnn(1),_',_ : _,A : ro.crossnn(1),_,_ : _,chain(As) : ro.crossnn(1),_,_)) ~ _ : !,_,_,_;
chain(A) = A;

//-------`inLeftWave`--------------
// Adds a signal to left going waves anywhere in a [`chain`](#chain) of blocks.
//
// #### Usage
//
// ```
// model(x) = chain(A : inLeftWave(x) : B)
// ```
//
// Where `A` and `B` are bidirectional blocks and `x` is the signal added to left
// going waves in that chain.
//--------------------------------
inLeftWave(x) = +(x),_,_;

//-------`inRightWave`--------------
// Adds a signal to right going waves anywhere in a [`chain`](#chain) of blocks.
//
// #### Usage
//
// ```
// model(x) = chain(A : inRightWave(x) : B)
// ```
//
// Where `A` and `B` are bidirectional blocks and `x` is the signal added to right
// going waves in that chain.
//--------------------------------
inRightWave(x) = _,+(x),_;

//-------`in`--------------
// Adds a signal to left and right going waves anywhere in a [`chain`](#chain)
// of blocks.
//
// #### Usage
//
// ```
// model(x) = chain(A : in(x) : B)
// ```
//
// Where `A` and `B` are bidirectional blocks and `x` is the signal added to
// left and right going waves in that chain.
//--------------------------------
in(x) = +(x),+(x),_;

//-------`outLeftWave`--------------
// Sends the signal of left going waves to the output channel of the [`chain`](#chain).
//
// #### Usage
//
// ```
// chain(A : outLeftWave : B)
// ```
//
// Where
//
// Where `A` and `B` are bidirectional blocks.
//--------------------------------
outLeftWave(x,y,s) = x,y,x+s;

//-------`outRightWave`--------------
// Sends the signal of right going waves to the output channel of the [`chain`](#chain).
//
// #### Usage
//
// ```
// chain(A : outRightWave : B)
// ```
//
// Where
//
// Where `A` and `B` are bidirectional blocks.
//--------------------------------
outRightWave(x,y,s) = x,y,y+s;

//-------`out`--------------
// Sends the signal of right and left going waves to the output channel of the [`chain`](#chain).
//
// #### Usage
//
// ```
// chain(A : out : B)
// ```
//
// Where
//
// Where `A` and `B` are bidirectional blocks.
//--------------------------------
out(x,y,s) = x,y,x+y+s;

//-------`terminations`--------------
// Creates terminations on both sides of a [`chain`](#chain) without closing the inputs and
// outputs of the bidirectional signals chain. As for [`chain`](#chain), this function adds a 1
// sample delay to the bidirectional signal, both ways. Of courses, this function can be nested
// within a [`chain`](#chain).
//
// #### Usage
//
// ```
// rightGoingWaves,leftGoingWaves,mixedOutput : terminations(a,b,c) : rightGoingWaves,leftGoingWaves,mixedOutput
// with{
//		a = *(-1); // left termination
//		b = chain(D:E:F); // bidirectional chain of blocks (D, E, F, etc.)
//		c = *(-1); // right termination
// };
// ```
//----------------------------------------
terminations(a,b,c) = (_,ro.crossnn(1),_,_ : +,+,_ : b) ~ (a,c : ro.crossnn(1));

//-------`leftTermination`----------
// Creates a termination on the left side of a [`chain`](#chain) without closing the inputs and
// outputs of the bidirectional signals chain. This function adds a 1 sample delay near
// the termination and can be nested within another [`chain`](#chain).
//
// #### Usage
//
// ```
// rightGoingWaves,leftGoingWaves,mixedOutput : terminations(a,b) : rightGoingWaves,leftGoingWaves,mixedOutput
// with{
//		a = *(-1); // left termination
//		b = chain(D : E : F); // bidirectional chain of blocks (D, E, F, etc.)
// };
// ```
//----------------------------------------
lTermination(a,b) = (ro.crossnn(1),_,_ : _,+,_ : b) ~ a;

//-------`rTermination`----------
// Creates a termination on the right side of a [`chain`](#chain) without closing the inputs and
// outputs of the bidirectional signals chain. This function adds a 1 sample delay near
// the termination and can be nested within another [`chain`](#chain).
//
// #### Usage
//
// ```
// rightGoingWaves,leftGoingWaves,mixedOutput : terminations(b,c) : rightGoingWaves,leftGoingWaves,mixedOutput
// with{
//		b = chain(D : E : F); // bidirectional chain of blocks (D, E, F, etc.)
//		c = *(-1); // right termination
// };
// ```
//----------------------------------------
rTermination(b,c) = (_,_,_,_ : +,_,_ : b) ~ (!,c);

//-------`closeIns`----------
// Closes the inputs of a bidirectional chain in all directions.
//
// #### Usage
//
// ```
// closeIns : chain(...) : 	_,_,_
// ```
//----------------------------------------
closeIns = 0,0,0;

//-------`closeOuts`----------
// Closes the outputs of a bidirectional chain in all directions except for the
// main signal output (3d output).
//
// #### Usage
//
// ```
// _,_,_ : chain(...) : closeOuts
// ```
//----------------------------------------
closeOuts = !,!,_;

//-------`endChain`----------
// Closes the inputs and outputs of a bidirectional chain in all directions
// except for the main signal output (3d output).
//
// #### Usage
//
// ```
// endChain(chain(...))
// ```
//----------------------------------------
endChain(b) = closeIns : b : closeOuts;


//==================================Basic Elements========================================
// TODO
//========================================================================================

//-------waveguide(nMax,n)----------
// A simple waveguide block based on a 4th order fractional delay.
// ### Usage
// ```
// rightGoingWaves,leftGoingWaves,mixedOutput : waveguide(nMax,n) : rightGoingWaves,leftGoingWaves,mixedOutput
// ```
// With:
// * `nMax`: the maximum length of the waveguide in samples and as a power of 2
// * `n` the length of the waveguide in samples.
// ### Requires
// `filter.lib` (`fdelay4`)
//----------------------------------
waveguideUd(nMax,n) = par(i,2,de.delay(nMax,n)),_;
waveguideFd(nMax,n) = par(i,2,de.fdelay(nMax,n)),_;
waveguideFd2(nMax,n) = par(i,2,de.fdelay2(nMax,n)),_;
waveguideFd4(nMax,n) = par(i,2,de.fdelay4(nMax,n)),_;
waveguide(nMax,n) = waveguideFd4(nMax,n);

// TODO doc
openString(maxLength,length) = waveguide(nMax,n)
with{
	nMax = (maxLength : l2s/2 : ma.np2)*0 + 2048; // TODO: temporary fix here: maxLength is not used!
	n = length : l2s/2;
};

// TODO doc
openTube = openString;

// TODO doc
ksReflexionFilter = _ <: (_+_')/2;

//=====================================Strings============================================
// TODO
//========================================================================================

// TODO doc
ksString(length,damping,excitation) = endChain(ksChain)
with{
	lengthTuning = 0.94;
	tunedLength = length*lengthTuning;
	refCoef = (1-damping)*0.2+0.8;
	refFilter = ksReflexionFilter*refCoef;
	ksChain = terminations(_,chain(in(excitation) : openString(tunedLength) : out),refFilter);
};

//=====================================Excitations========================================
// TODO
//========================================================================================

//-------impulseExcitation(gate)--------------
// Creates an impulse excitation of one sample, from a gate button when it is triggered.
// ### Usage
// ```
// gate = button('gate');
// impulseExcitation(gate) : chain;
// ```
// With:
// * `gateÌ€: a gate button
//--------------------------------------
impulseExcitation(trigger) = trigger : ba.impulsify;








//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// OLD SECTIONS BEYOND THIS MARK
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

//-------idealString(length,reflexion,xPosition,x)----------
// An ideal string with rigid terminations and where the plucking position and the
// pick-up position are the same.
// ### Usage
// ```
// 1-1' : idealString(length,reflexion,xPosition,x)
// ```
// With:
// * `length`: the length of the string in meters
// * `reflexion`: the coefficient of reflexion (0-0.99999999)
// * `pluckPosition`: the plucking position (0.001-0.999)
// * `x`: the input signal for the excitation
// ### Requires
// `filter.lib` (`fdelay4`,`crossnn`)
//----------------------------------------------------------
idealString(length,reflexion,pluckPosition,x) = fullTerminations(term,wg,term)
with{
	nMax = 512; // each segment of the string can't be longer than that
	N = length*ma.SR/320-8; // length (meters) to samples
	nUp = N/2*pluckPosition : max(1); // upper string segment length
	nDown = N/2*(1-pluckPosition) : max(1); // lower string segment length
	wg = chain(waveguide(nMax,nUp) : input(x) : output : waveguide(nMax,nDown)); // waveguide chain
	term = *(-reflexion); // terminations
};

//-------dampingFilter(rho,h0,h1,x)--------------------
// TODO
//-----------------------------------------------------
dampingFilter(rho,h0,h1,x) = rho * (h0 * x' + h1*(x+x''));

//-------bridge(length,B,t60,x)-----------
// Simulate a bridge using a dampingFilter.
// ### Usage
// ```
//
// ```
// With:
// * `length`: length of the string in meters
// * `B`: the brightness of the string (0-0.99)
// * `t60Ì€: decaying time
// * `x`: the input signal for the excitation
// ### Requires
// `filter.lib`
//------------------------------------------------------
/*
bridge(length,B,t60,x) = dampingFilter(rho,h0,h1,x)
with{
	freq = 320/length;
	h0 = (1.0 + B)/2;
	h1 = (1.0 - B)/4;
	rho = pow(0.001,1.0/(freq*t60));
};
*/

//-------steelString-----------------------------
//-----------------------------------------------
steelString(length,pluckPosition,x) = fullTerminations(bridge,wg,bridge)
with{
	nMax = 512; // each segment of the string can't be longer than that
	N = length*SR/320-8; // length (meters) to samples
	nUp = N/2*pluckPosition : max(1); // upper string segment length
	nDown = N/2*(1-pluckPosition) : max(1); // lower string segment length
	wg = chain(waveguide(nMax,nUp) : input(x) : output : waveguide(nMax,nDown)); // waveguide chain
	bridge = bridge(length,B,t60,x)
	with{
		B = 0.8;
		t60 = 6;
	};
};

//-------nylonString-----------------------------
//-----------------------------------------------
nylonString(length,pluckPosition,B,t60,x) = fullTerminations(term,wg,term)
with{
	nMax = 512; // each segment of the string can't be longer than that
	N = length*SR/320-8; // length (meters) to samples
	nUp = N/2*pluckPosition : max(1); // upper string segment length
	nDown = N/2*(1-pluckPosition) : max(1); // lower string segment length
	wg = chain(waveguide(nMax,nUp) : input(x) : output : waveguide(nMax,nDown)); // waveguide chain

	term(x) = bridge(length,B,t60,x)
	with{
		B = 0.25;
		t60 = 4;
	};
};


//-------acousticExcitation(gate,P)-------------
// Creates an acoustic excitation (a noise burst) when a gate button is triggered.
// ### Usage
// ```
// gate = button('gate');
// P = SR/freq;
// acousticExcitation(gate,P) : chain;
// ```
// With:
// * `gateÌ€: a gate button
// * `PÌ€ : fundamental period in samples
// ### Requires
// 'music.lib' (noise)
//--------------------------------------
acousticExcitation(gate,P) = no.noise : *(gate : trigger(P))
with {
     diffgtz(x) = (x-x') > 0;
     decay(n,x) = x-(x>0)/n;
     release(n) = + ~ decay(n);
     trigger(n) = diffgtz : release(n) : > (0.0);
};


//-----modeFilter-----
modeFilter(f,t60) = tf2(b0,b1,b2,a1,a2)
with{
	b0 = 1;
	b1 = 0;
	b2 = -1;
	w = 2*PI*f/SR;
	r = pow(0.001,1/float(t60*SR));
	a1 = -2*r*cos(w);
	a2 = r^2;
};

//---modalModel--
// modeFreqs : list of modal frequencies
// modeRes : list of t60 corresponding to the frequencies
// modeGains : list of gains corresponding to the frequencies
//--------------
modalModel(n,modeFreqs,modeRes,modeGains) = _ <: par(i,n,gain(i)*modeFilter(freqs(i),res(i))) :> _
with{
	freqs(i) = take(i+1,modeFreqs);
	res(i) = take(i+1,modeRes);
	gain(i) = take(i+1,modeGains);
};
